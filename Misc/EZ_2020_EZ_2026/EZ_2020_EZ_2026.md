# Challenge: EZ_2020_EZ_2026
## Information
<img width="1101" height="282" alt="image" src="https://github.com/user-attachments/assets/70f5c604-a7ad-46b5-898f-9d18996a1fc1" />

## Solution
Upon downloading and extracting the initial `2020.zip` file, we obtain another archive named `0.zip`.  
Extracting this yields `1.zip`. Repeating the process reveals a pattern of nested zip files, alternating between names like `0.zip` and `1.zip`.

Since extracting them manually is tedious due to the large depth, we wrote a Python script to automate the extraction process.  
```python
import zipfile
import io

def unzip(filename="2020.zip"):
    current_resource = filename 
    
    layer = 0

    while True:
        try:
            with zipfile.ZipFile(current_resource, 'r') as zf:
                file_list = zf.namelist()
                layer += 1
                
                print(f"[Layer {layer}] {file_list}")

                if not file_list:
                    print("[!] Empty file")
                    break

                next_file = file_list[0]
                content = zf.read(next_file)

                if content.startswith(b'PK'):
                    current_resource = io.BytesIO(content)
                else:
                    print(f"[!] Final:\n{content.decode(errors='ignore')}")
                    break
                    
        except zipfile.BadZipFile:
            print("[!] Error file")
            break
        except Exception as e:
            print(f"Error: {e}")
            break

if __name__ == "__main__":
    unzip()
```
  
The content of the final text file does not contain the flag. However, we noticed that the filenames of the nested archives are strictly `0` and `1`. This suggests that the filenames themselves form a binary string.

<img width="461" height="517" alt="image" src="https://github.com/user-attachments/assets/9925775c-207d-4ce7-af44-66505adbc04f" />  

  
We modified the script to concatenate the filenames (0 or 1) into a binary string as we traverse through the layers. We then convert this binary string into text.  
```python
import zipfile
import io
import os

def unzip_and_decode(filename="2020.zip"):
    current_resource = filename 
    layer = 0
    binary_string = ""

    while True:
        try:
            with zipfile.ZipFile(current_resource, 'r') as zf:
                file_list = zf.namelist()
                layer += 1

                if not file_list:
                    print("[!] Empty file")
                    break

                next_file = file_list[0]
                
                name_part = os.path.splitext(next_file)[0]
                if name_part in ['0', '1']:
                    binary_string += name_part

                content = zf.read(next_file)

                if content.startswith(b'PK'):
                    current_resource = io.BytesIO(content)
                else:
                    print(f"\n[!] Final content:\n{content.decode(errors='ignore').strip()}")
                    break
                    
        except zipfile.BadZipFile:
            print("[!] Error file or not a zip")
            break
        except Exception as e:
            print(f"Error: {e}")
            break

    if binary_string:
        try:
            decimal_value = int(binary_string, 2)
            
            hex_string = "{:x}".format(decimal_value)
            print(f"[*] Hex String: {hex_string}")

            flag = bytes.fromhex(hex_string).decode('utf-8')
            print(f"\n[+] Flag: {flag}")
            
        except Exception as e:
            print(f"[!] Error when decode: {e}")
            print(f"Binary raw: {binary_string}")

if __name__ == "__main__":
    unzip_and_decode()
```

<img width="813" height="353" alt="image" src="https://github.com/user-attachments/assets/6805bc2c-7d0d-408f-8a1d-c0f098ef2d03" />

The script output showed that the binary string decoded into a hex string. We applied `bytes.fromhex()` one last time to reveal the final flag.

Flag: `W1{https://www.youtube.com/watch?v=sFUmPSyG61c&list=RDsFUmPSyG61c&start_radio=1}`
