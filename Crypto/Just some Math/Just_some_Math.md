# Challenge: Just some Math
## Information
<img width="1074" height="285" alt="image" src="https://github.com/user-attachments/assets/b620f49b-90ee-4dbe-a201-e16e52603bc6" />

## Solution
Dựa vào file `chall.py`, ta có các thông tin sau:
- Flag được chuyển thành số nguyên `pt` với độ dài hơn 800 bits.
- Hệ thống RSA sử dụng hai số nguyên tố $p,q$ (mỗi số 512 bits) và số mũ công khai $e$ (256 bits).
- Lỗ hổng: In ra giá trị $i^e \pmod p$ với $i$ chạy từ 2 đến 6.
Vì `pt` (800+ bits) lớn hơn `p` (512 bits), ta không thể lấy toàn bộ Flag chỉ bằng cách giải mã theo modulo $p$. Do đó cần thu thập dữ liệu từ ít nhất 2 - 3 lần chạy để dùng Định lý số dư Trung Hoa (CRT).  

### Bước 1: Khôi phục số nguyên tố $p$
Dựa trên các giá trị được cung cấp:
- $R_2 = 2^e \pmod p$
- $R_3 = 3^e \pmod p$
- $R_4 = 4^e \pmod p$
- $R_6 = 6^e \pmod p$
  
Ta có các tính chất toán học sau:
- $4^e = (2^2)^e = (2^e)^2 \implies R_4 \equiv R_2^2 \pmod p$
- $6^e = (2 \cdot 3)^e = 2^e \cdot 3^e \implies R_6 \equiv R_2 \cdot R_3 \pmod p$
  
Điều này đồng nghĩa với việc:
- $$p \mid (R_2^2 - R_4)$$
- $p \mid (R_2 \cdot R_3 - R_6)$

Bằng cách tính Ước chung lớn nhất (GCD) của hai hiệu số trên, ta sẽ tìm được số nguyên tố $p$:

$$p = \text{gcd}(|R_2^2 - R_4|, |R_2 \cdot R_3 - R_6|)$$

### Bước 2: Giải mã từng phần Flag
Sau khi có $p$, ta tính số mũ giải mã cục bộ $d_p$ (số nghịch đảo của $e$ theo modulo $\phi(p) = p-1$):

$$d_p = e^{-1} \pmod{p-1}$$

Giá trị Flag theo modulo $p$ là:

$$mp = ct^{d_p} \pmod p$$

### Bước 3: Hợp nhất bằng Định lý số dư Trung Hoa (CRT)
Giả sử ta thực hiện 3 lần chạy, ta thu được 3 cặp dữ liệu: $(mp_1, p_1), (mp_2, p_2), (mp_3, p_3)$.  
Sử dụng CRT để tìm số $X$ sao cho:

$$\begin{cases} X \equiv mp_1 \pmod{p_1} \\ 
X \equiv mp_2 \pmod{p_2} \\ 
X \equiv mp_3 \pmod{p_3} \end{cases}$$

Vì tích $p_1 \cdot p_2 \cdot p_3 \approx 1536$ bits, lớn hơn Flag (800+ bits), nên giá trị $X$ tìm được chính là Flag gốc.


```python
import re
from math import gcd
from Crypto.Util.number import inverse, long_to_bytes, isPrime

RUNS = [
r"""
ct = 30635402713573718159601622485873641283433096211751515977916153586813841976204067617926984032877412846355896188635256062908430393558696572064648465708764489962255572367747496674446047827987753646759857037851044025067549630995481676873387925687471577658858348456961292119939164447122303020574897763145268521652
e = 62626761219850718734044858764615246817142278055694025146352578923402315500293
2^e mod p = 10554675855003467612613157039323554507606126152001261794269504215223068163348835606176188062822137506251266260884910860572783233516577604210134833525972501
3^e mod p = 2805495322190300539109950196424206964045790517677055673494358881528724824504675301289687600487992794669009251334148468404768258706485671782139921581073606
4^e mod p = 4723774322371896209826256408889294039432608056688487287120614859972353142574031648482376940632872623129533297364978505797662812319737339256314711461714011
5^e mod p = 9826201419294478246039822554620441821947659292772046596525383841996333775307916703108584593558532978314325483498598207226553631263943509153478852986578073
6^e mod p = 1298226211007739108083896335847250562316399716418168124447874773148178032931785900577949577862804317424759461514977254223627528788254260088418094488005790
""",
r"""
ct = 23934143304284305340298672634783855759718548322470213650101135425123826717776063345620954648820130425275655586125270512295468840354464504413151312070641947017697703248792487471588121431983598392508764306008942246647177108800048707263066851504952204226670895671370614318767557015593738687936313303430583734475
e = 60641440257495123032692716113577547512485020425141911421660086864964328703131
2^e mod p = 3154574532164626002294975065766765696245178964525686561730360920908765696268777324243703545833694824786466039321296600385892795117200762723024960234606329
3^e mod p = 520187909575952575540091042193094685570588435252299636584179511164377886893645470834551848841644431260009793869782437462396403834629067674189040588474828
4^e mod p = 6407659638714007793127141657971886364751546248606447236341599297338308549344077267239302770689418166612367709713175109618969262437493995940478556465523356
5^e mod p = 7959329346754037907135766618917843674284283960316641254016531654950265461887737510833293949306124281592931957352835345934370963170675280130360447981949300
6^e mod p = 4988372383447357456358682806902883742872263487262357626264083600416116654224587534761993225957043396287183409955433766907871192365171113866107229911898891
""",
r"""
ct = 12469386077693906784561368467332079082452339341105689596436405936136159008937809645034537967377204928588646727217997276656337685949691299208400064911168461517593232735013056159311897150567797607990668680617478839375244125204407915231707863924433003827522762600304602231879575690071276001943027717142574874310
e = 71168213575873521653675873063978279904219729085281747934895597289087465900409
2^e mod p = 5577237197732486258482836531883121773340484358274075959437826869460053567160494273007796036537843009402015222742479068086250911502915859182971335738627582
3^e mod p = 5477017040161244158577852736219831267210134248861710992846998465159179821104687940869794920119433202097399364591480559620307146700670881155131523776703435
4^e mod p = 6505064645866052836313888393494439685843034203959886864300275172098525905410536156701292116288705702103030327338272929579012443207198968116186690819865326
5^e mod p = 2344383838643966949673516857905942973753461921989384038698711675326309059140113156987001335870050432781042437104859475883623812891073655904571985960081581
6^e mod p = 465209748697929095384920042889324890908233842285619231711433916649279015875383259034636229713586307320352579739288244101449805351086279863538037392002658
"""
]

def parse_run(s: str):
    ct = int(re.search(r'ct\s*=\s*(\d+)', s).group(1))
    e = int(re.search(r'e\s*=\s*(\d+)', s).group(1))
    rs = {}
    for base in [2, 3, 4, 5, 6]:
        val = int(re.search(rf'{base}\^e mod p\s*=\s*(\d+)', s).group(1))
        rs[base] = val
    return ct, e, rs

def recover_p(rs, target_bits=512):
    r2, r3, r4, r6 = rs[2], rs[3], rs[4], rs[6]
    
    g = gcd(abs(r2*r2 - r4), abs(r2*r3 - r6))
    
    while g % 2 == 0: g //= 2
    
    if isPrime(g) and abs(g.bit_length() - target_bits) <= 2:
        return g
        
    small_primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    for f in small_primes:
        while g % f == 0:
            g //= f
        if isPrime(g) and abs(g.bit_length() - target_bits) <= 2:
            return g
    return g

def crt_pair(a1, m1, a2, m2):
    inv = inverse(m1 % m2, m2)
    k = ((a2 - a1) * inv) % m2
    x = a1 + k * m1
    return x, m1 * m2

def main():
    mods, rems = [], []
    
    for idx, block in enumerate(RUNS, 1):
        ct, e, rs = parse_run(block)
        p = recover_p(rs)
        
        dp = inverse(e, p - 1)
        mp = pow(ct % p, dp, p)
        
        mods.append(p)
        rems.append(mp)

    x, M = rems[0], mods[0]
    for i in range(1, len(mods)):
        x, M = crt_pair(x, M, rems[i], mods[i])

    try:
        flag = long_to_bytes(x)
        print(f"Flag: {flag.decode()}")
    except Exception as e:
        print(f"\n Error when decode flag: {e}")
        print(f"Long value: {x}")

if __name__ == "__main__":
    main()
```

<img width="552" height="95" alt="image" src="https://github.com/user-attachments/assets/28069e2e-2b0b-4e6c-b10b-703d574d19ad" />
